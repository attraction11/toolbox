{"version":3,"file":"scheduler.esm.js","sources":["../src/SchedulerPriorities.ts","../src/SchedulerMinHeap.ts","../src/Scheduler.ts"],"sourcesContent":["export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5;\n\n// 任务优先级\n// 优先级越高，值越小\nexport const NoPriority = 0;\nexport const ImmediatePriority = 1;\nexport const UserBlockingPriority = 2;\nexport const NormalPriority = 3;\nexport const LowPriority = 4;\nexport const IdlePriority = 5;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nconst maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nexport const IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nexport const USER_BLOCKING_PRIORITY_TIMEOUT = 250;\nexport const NORMAL_PRIORITY_TIMEOUT = 5000;\nexport const LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nexport const IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\n\nexport function getTimeoutByPriorityLevel(priorityLevel: PriorityLevel) {\n  let timeout: number;\n\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n      break;\n    case UserBlockingPriority:\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n      break;\n    case IdlePriority:\n      timeout = IDLE_PRIORITY_TIMEOUT;\n      break;\n    case LowPriority:\n      timeout = LOW_PRIORITY_TIMEOUT;\n      break;\n    case NormalPriority:\n    default:\n      timeout = NORMAL_PRIORITY_TIMEOUT;\n      break;\n  }\n\n  return timeout;\n}\n","export type Heap = Array<Node>;\n\nexport type Node = {\n  id: number;\n  sortIndex: number;\n};\n\nexport function push(heap: Heap, node: Node): void {\n  const index = heap.length;\n  heap.push(node);\n  siftUp(heap, node, index);\n}\n\nexport function peek(heap: Heap): Node | null {\n  return heap.length === 0 ? null : heap[0];\n}\n\nexport function pop(heap: Heap): Node | null {\n  if (heap.length === 0) {\n    return null;\n  }\n  const first = heap[0];\n  const last = heap.pop();\n  if (last !== first) {\n    heap[0] = last!;\n    siftDown(heap, last!, 0);\n  }\n  return first;\n}\n\nfunction siftUp(heap: Heap, node: Node, i: number) {\n  let index = i;\n  while (index > 0) {\n    const parentIndex = (index - 1) >>> 1;\n    const parent = heap[parentIndex];\n    if (compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node;\n      heap[index] = parent;\n      index = parentIndex;\n    } else {\n      // The parent is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction siftDown(heap: Heap, node: Node, i: number) {\n  let index = i;\n  const length = heap.length;\n  const halfLength = length >>> 1;\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1;\n    const left = heap[leftIndex];\n    const rightIndex = leftIndex + 1;\n    const right = heap[rightIndex];\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compare(left, node) < 0) {\n      if (rightIndex < length && compare(right, left) < 0) {\n        heap[index] = right;\n        heap[rightIndex] = node;\n        index = rightIndex;\n      } else {\n        heap[index] = left;\n        heap[leftIndex] = node;\n        index = leftIndex;\n      }\n    } else if (rightIndex < length && compare(right, node) < 0) {\n      heap[index] = right;\n      heap[rightIndex] = node;\n      index = rightIndex;\n    } else {\n      // Neither child is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction compare(a: Node, b: Node) {\n  // Compare sort index first, then task id.\n  const diff = a.sortIndex - b.sortIndex;\n  return diff !== 0 ? diff : a.id - b.id;\n}\n","import {push, pop, peek} from \"./SchedulerMinHeap\";\nimport {getCurrentTime, isFn, isObject} from \"shared/utils\";\nimport {\n  getTimeoutByPriorityLevel,\n  NormalPriority,\n  PriorityLevel,\n} from \"./SchedulerPriorities\";\n\ntype Callback = any; // (args: any) => void | any;\n\nexport interface Task {\n  id: number;\n  callback: Callback;\n  priorityLevel: PriorityLevel;\n  startTime: number;\n  expirationTime: number;\n  sortIndex: number;\n}\n\ntype HostCallback = (hasTimeRemaining: boolean, currentTime: number) => boolean;\n\n// 任务存储，最小堆\nconst taskQueue: Array<Task> = [];\nconst timerQueue: Array<Task> = [];\n\nlet taskIdCounter: number = 1;\n\nlet currentTask: Task | null = null;\nlet currentPriorityLevel: PriorityLevel = NormalPriority;\n\n// 在计时\nlet isHostTimeoutScheduled: boolean = false;\n\n// 在调度任务\nlet isHostCallbackScheduled = false;\n// This is set while performing work, to prevent re-entrance.\nlet isPerformingWork = false;\n\nlet schedulePerformWorkUntilDeadline: Function;\n\nlet isMessageLoopRunning = false;\nlet scheduledHostCallback: HostCallback | null = null;\nlet taskTimeoutID: number = -1;\n\nlet startTime = -1;\n\nlet needsPaint = false;\n\n// Scheduler periodically yields in case there is other work on the main\n// thread, like user events. By default, it yields multiple times per frame.\n// It does not attempt to align with frame boundaries, since most tasks don't\n// need to be frame aligned; for those that do, use requestAnimationFrame.\nlet frameInterval = 5; //frameYieldMs;\n\nfunction cancelHostTimeout() {\n  clearTimeout(taskIdCounter);\n  taskIdCounter = -1;\n}\n\nfunction requestHostTimeout(callback: Callback, ms: number) {\n  taskIdCounter = setTimeout(() => {\n    callback(getCurrentTime());\n  }, ms);\n}\n\n// 检查timerQueue中的任务，是否有任务到期了呢，到期了就把当前有效任务移动到taskQueue\nfunction advanceTimers(currentTime: number) {\n  let timer: Task = peek(timerQueue) as Task;\n  while (timer !== null) {\n    if (timer.callback === null) {\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n    } else {\n      return;\n    }\n    timer = peek(timerQueue) as Task;\n  }\n}\n\n// 倒计时到点了\nfunction handleTimeout(currentTime: number) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else {\n      const firstTimer: Task = peek(timerQueue) as Task;\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\n\n// todo\nfunction requestHostCallback(callback: Callback) {\n  scheduledHostCallback = callback;\n\n  if (!isMessageLoopRunning) {\n    isMessageLoopRunning = true;\n    schedulePerformWorkUntilDeadline();\n  }\n}\n\nconst performWorkUntilDeadline = () => {\n  if (scheduledHostCallback !== null) {\n    const currentTime = getCurrentTime();\n\n    // Keep track of the start time so we can measure how long the main thread\n    // has been blocked.\n    startTime = currentTime;\n\n    const hasTimeRemaining = true;\n    let hasMoreWork = true;\n    try {\n      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n    } finally {\n      if (hasMoreWork) {\n        schedulePerformWorkUntilDeadline();\n      } else {\n        isMessageLoopRunning = false;\n        scheduledHostCallback = null;\n      }\n    }\n  } else {\n    isMessageLoopRunning = false;\n  }\n};\n\nconst channel = new MessageChannel();\n\nconst port = channel.port2;\n\nchannel.port1.onmessage = performWorkUntilDeadline;\n\nschedulePerformWorkUntilDeadline = () => {\n  port.postMessage(null);\n};\n\nfunction flushWork(hasTimeRemaining: boolean, initialTime: number) {\n  isHostCallbackScheduled = false;\n\n  if (isHostTimeoutScheduled) {\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  isPerformingWork = true;\n\n  let previousPriorityLevel = currentPriorityLevel;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n  }\n}\n\n// 在当前时间切片内循环执行任务\nfunction workLoop(hasTimeRemaining: boolean, initialTime: number) {\n  let currentTime = initialTime;\n\n  advanceTimers(currentTime);\n  currentTask = peek(taskQueue) as Task;\n\n  while (currentTask !== null) {\n    const should = shouldYieldToHost();\n    if (\n      currentTask.expirationTime > currentTime &&\n      (!hasTimeRemaining || should)\n    ) {\n      // 当前任务还没有过期，并且没有剩余时间了\n      break;\n    }\n\n    const callback = currentTask.callback;\n    currentPriorityLevel = currentTask.priorityLevel;\n    if (isFn(callback)) {\n      currentTask.callback = null;\n\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n\n      const continuationCallback = callback(didUserCallbackTimeout);\n\n      currentTime = getCurrentTime();\n      if (isFn(continuationCallback)) {\n        // 任务没有执行完\n        currentTask.callback = continuationCallback;\n        advanceTimers(currentTime);\n        return true;\n      } else {\n        if (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n        advanceTimers(currentTime);\n      }\n    } else {\n      // currentTask不是有效任务\n      pop(taskQueue);\n    }\n    currentTask = peek(taskQueue) as Task;\n  }\n\n  // 判断还有没有其他的任务\n  if (currentTask !== null) {\n    return true;\n  } else {\n    const firstTimer = peek(timerQueue) as Task;\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n    return false;\n  }\n}\n\nfunction shouldYieldToHost() {\n  const timeElapsed = getCurrentTime() - startTime;\n\n  if (timeElapsed < frameInterval) {\n    // The main thread has only been blocked for a really short amount of time;\n    // smaller than a single frame. Don't yield yet.\n    return false;\n  }\n\n  return true;\n}\n\nexport function scheduleCallback(\n  priorityLevel: PriorityLevel,\n  callback: Callback,\n  options?: {delay: number}\n) {\n  //任务进入调度器的时间\n  const currentTime = getCurrentTime();\n  let startTime: number;\n\n  if (isObject(options) && options !== null) {\n    let delay = options?.delay;\n    if (typeof delay === \"number\" && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n  } else {\n    startTime = currentTime;\n  }\n\n  const timeout = getTimeoutByPriorityLevel(priorityLevel);\n  const expirationTime = startTime + timeout;\n\n  const newTask = {\n    id: taskIdCounter++,\n    callback,\n    priorityLevel,\n    startTime, //任务开始调度的理论时间\n    expirationTime, //过期时间\n    sortIndex: -1,\n  };\n\n  if (startTime > currentTime) {\n    // 有延迟的任务\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n      //\n      if (isHostTimeoutScheduled) {\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      }\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    newTask.sortIndex = expirationTime;\n    push(taskQueue, newTask);\n\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n}\n\n// 取消任务\nexport function cancelCallback(task: Task) {\n  // Null out the callback to indicate the task has been canceled. (Can't\n  // remove from the queue because you can't remove arbitrary nodes from an\n  // array based heap, only the first one.)\n  // 取消任务，不能直接删除，因为最小堆中只能删除堆顶元素\n  task.callback = null;\n}\n\n// 获取当前任务优先级\nexport function getCurrentPriorityLevel(): PriorityLevel {\n  return currentPriorityLevel;\n}\n\nexport function requestPaint() {\n  // if (\n  //   enableIsInputPending &&\n  //   navigator !== undefined &&\n  //   // $FlowFixMe[prop-missing]\n  //   navigator.scheduling !== undefined &&\n  //   // $FlowFixMe[incompatible-type]\n  //   navigator.scheduling.isInputPending !== undefined\n  // ) {\n  //   needsPaint = true;\n  // }\n  // Since we yield every frame regardless, `requestPaint` has no effect.\n}\n\n// heap中谁的任务优先级最高先去执行谁，这里说的“任务优先级”不是priorityLevel\n"],"names":["NoPriority","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY_TIMEOUT","NORMAL_PRIORITY_TIMEOUT","LOW_PRIORITY_TIMEOUT","IDLE_PRIORITY_TIMEOUT","getTimeoutByPriorityLevel","priorityLevel","timeout","push","heap","node","index","siftUp","peek","pop","first","last","siftDown","i","parentIndex","parent","compare","length","halfLength","leftIndex","left","rightIndex","right","a","b","diff","taskQueue","timerQueue","taskIdCounter","currentTask","currentPriorityLevel","isHostTimeoutScheduled","isHostCallbackScheduled","isPerformingWork","schedulePerformWorkUntilDeadline","isMessageLoopRunning","scheduledHostCallback","startTime","frameInterval","cancelHostTimeout","requestHostTimeout","callback","ms","getCurrentTime","advanceTimers","currentTime","timer","handleTimeout","requestHostCallback","flushWork","firstTimer","performWorkUntilDeadline","hasTimeRemaining","hasMoreWork","channel","port","initialTime","previousPriorityLevel","workLoop","should","shouldYieldToHost","isFn","didUserCallbackTimeout","continuationCallback","scheduleCallback","options","isObject","delay","expirationTime","newTask","cancelCallback","task","getCurrentPriorityLevel","requestPaint"],"mappings":";AAIO,MAAMA,KAAa,GACbC,IAAoB,GACpBC,IAAuB,GACvBC,IAAiB,GACjBC,IAAc,GACdC,IAAe,GAKtBC,IAAoB,YAGbC,IAA6B,IAE7BC,IAAiC,KACjCC,IAA0B,KAC1BC,IAAuB,KAEvBC,IAAwBL;AAE9B,SAASM,EAA0BC,GAA8B;AAClE,MAAAC;AAEJ,UAAQD,GAAe;AAAA,IACrB,KAAKZ;AACO,MAAAa,IAAAP;AACV;AAAA,IACF,KAAKL;AACO,MAAAY,IAAAN;AACV;AAAA,IACF,KAAKH;AACO,MAAAS,IAAAH;AACV;AAAA,IACF,KAAKP;AACO,MAAAU,IAAAJ;AACV;AAAA,IACF,KAAKP;AAAA,IACL;AACY,MAAAW,IAAAL;AACV;AAAA,EACJ;AAEO,SAAAK;AACT;ACzCgB,SAAAC,EAAKC,GAAYC,GAAkB;AACjD,QAAMC,IAAQF,EAAK;AACnB,EAAAA,EAAK,KAAKC,CAAI,GACPE,EAAAH,GAAMC,GAAMC,CAAK;AAC1B;AAEO,SAASE,EAAKJ,GAAyB;AAC5C,SAAOA,EAAK,WAAW,IAAI,OAAOA,EAAK;AACzC;AAEO,SAASK,EAAIL,GAAyB;AACvC,MAAAA,EAAK,WAAW;AACX,WAAA;AAET,QAAMM,IAAQN,EAAK,IACbO,IAAOP,EAAK;AAClB,SAAIO,MAASD,MACXN,EAAK,KAAKO,GACDC,EAAAR,GAAMO,GAAO,CAAC,IAElBD;AACT;AAEA,SAASH,EAAOH,GAAYC,GAAYQ,GAAW;AACjD,MAAIP,IAAQO;AACZ,SAAOP,IAAQ,KAAG;AACV,UAAAQ,IAAeR,IAAQ,MAAO,GAC9BS,IAASX,EAAKU;AACpB,QAAIE,EAAQD,GAAQV,CAAI,IAAI;AAE1B,MAAAD,EAAKU,KAAeT,GACpBD,EAAKE,KAASS,GACNT,IAAAQ;AAAA;AAGR;AAAA,EAEJ;AACF;AAEA,SAASF,EAASR,GAAYC,GAAYQ,GAAW;AACnD,MAAIP,IAAQO;AACZ,QAAMI,IAASb,EAAK,QACdc,IAAaD,MAAW;AAC9B,SAAOX,IAAQY,KAAY;AACnB,UAAAC,KAAab,IAAQ,KAAK,IAAI,GAC9Bc,IAAOhB,EAAKe,IACZE,IAAaF,IAAY,GACzBG,IAAQlB,EAAKiB;AAGnB,QAAIL,EAAQI,GAAMf,CAAI,IAAI;AACxB,MAAIgB,IAAaJ,KAAUD,EAAQM,GAAOF,CAAI,IAAI,KAChDhB,EAAKE,KAASgB,GACdlB,EAAKiB,KAAchB,GACXC,IAAAe,MAERjB,EAAKE,KAASc,GACdhB,EAAKe,KAAad,GACVC,IAAAa;AAAA,aAEDE,IAAaJ,KAAUD,EAAQM,GAAOjB,CAAI,IAAI;AACvD,MAAAD,EAAKE,KAASgB,GACdlB,EAAKiB,KAAchB,GACXC,IAAAe;AAAA;AAGR;AAAA,EAEJ;AACF;AAEA,SAASL,EAAQO,GAASC,GAAS;AAE3B,QAAAC,IAAOF,EAAE,YAAYC,EAAE;AAC7B,SAAOC,MAAS,IAAIA,IAAOF,EAAE,KAAKC,EAAE;AACtC;AC7DA,MAAME,IAAyB,CAAA,GACzBC,IAA0B,CAAA;AAEhC,IAAIC,IAAwB,GAExBC,IAA2B,MAC3BC,IAAsCvC,GAGtCwC,IAAkC,IAGlCC,IAA0B,IAE1BC,IAAmB,IAEnBC,GAEAC,IAAuB,IACvBC,IAA6C,MAG7CC,IAAY,IAQZC,IAAgB;AAEpB,SAASC,IAAoB;AAC3B,eAAaX,CAAa,GACVA,IAAA;AAClB;AAEA,SAASY,EAAmBC,GAAoBC,GAAY;AAC1D,EAAAd,IAAgB,WAAW,MAAM;AAC/B,IAAAa,EAASE,GAAgB;AAAA,KACxBD,CAAE;AACP;AAGA,SAASE,EAAcC,GAAqB;AACtC,MAAAC,IAActC,EAAKmB,CAAU;AACjC,SAAOmB,MAAU,QAAM;AACjB,QAAAA,EAAM,aAAa;AACrB,MAAArC,EAAIkB,CAAU;AAAA,aACLmB,EAAM,aAAaD;AAC5B,MAAApC,EAAIkB,CAAU,GACdmB,EAAM,YAAYA,EAAM,gBACxB3C,EAAKuB,GAAWoB,CAAK;AAAA;AAErB;AAEF,IAAAA,IAAQtC,EAAKmB,CAAU;AAAA,EACzB;AACF;AAGA,SAASoB,EAAcF,GAAqB;AAI1C,MAHyBd,IAAA,IACzBa,EAAcC,CAAW,GAErB,CAACb;AACC,QAAAxB,EAAKkB,CAAS,MAAM;AACI,MAAAM,IAAA,IAC1BgB,EAAoBC,CAAS;AAAA,SACxB;AACC,YAAAC,IAAmB1C,EAAKmB,CAAU;AACxC,MAAIuB,MAAe,QACEV,EAAAO,GAAeG,EAAW,YAAYL,CAAW;AAAA,IAExE;AAEJ;AAGA,SAASG,EAAoBP,GAAoB;AACvB,EAAAL,IAAAK,GAEnBN,MACoBA,IAAA,IACUD;AAErC;AAEA,MAAMiB,IAA2B,MAAM;AACrC,MAAIf,MAA0B,MAAM;AAClC,UAAMS,IAAcF;AAIR,IAAAN,IAAAQ;AAEZ,UAAMO,IAAmB;AACzB,QAAIC,IAAc;AACd,QAAA;AACY,MAAAA,IAAAjB,EAAsBgB,GAAkBP,CAAW;AAAA,IAAA,UACjE;AACA,MAAIQ,IAC+BnB,OAEVC,IAAA,IACCC,IAAA;AAAA,IAE5B;AAAA,EAAA;AAEuB,IAAAD,IAAA;AAE3B,GAEMmB,IAAU,IAAI,kBAEdC,IAAOD,EAAQ;AAErBA,EAAQ,MAAM,YAAYH;AAE1BjB,IAAmC,MAAM;AACvC,EAAAqB,EAAK,YAAY,IAAI;AACvB;AAEA,SAASN,EAAUG,GAA2BI,GAAqB;AACvC,EAAAxB,IAAA,IAEtBD,MACuBA,IAAA,IACPQ,MAGDN,IAAA;AAEnB,MAAIwB,IAAwB3B;AACxB,MAAA;AACK,WAAA4B,EAASN,GAAkBI,CAAW;AAAA,EAAA,UAC7C;AACc,IAAA3B,IAAA,MACSC,IAAA2B,GACJxB,IAAA;AAAA,EACrB;AACF;AAGA,SAASyB,EAASN,GAA2BI,GAAqB;AAChE,MAAIX,IAAcW;AAKlB,OAHAZ,EAAcC,CAAW,GACzBhB,IAAcrB,EAAKkB,CAAS,GAErBG,MAAgB,QAAM;AAC3B,UAAM8B,IAASC;AACf,QACE/B,EAAY,iBAAiBgB,MAC5B,CAACO,KAAoBO;AAGtB;AAGF,UAAMlB,IAAWZ,EAAY;AAEzB,QADJC,IAAuBD,EAAY,eAC/BgC,EAAKpB,CAAQ,GAAG;AAClB,MAAAZ,EAAY,WAAW;AAEjB,YAAAiC,IAAyBjC,EAAY,kBAAkBgB,GAEvDkB,IAAuBtB,EAASqB,CAAsB;AAGxD,UADJjB,IAAcF,EAAe,GACzBkB,EAAKE,CAAoB;AAE3B,eAAAlC,EAAY,WAAWkC,GACvBnB,EAAcC,CAAW,GAClB;AAEH,MAAAhB,MAAgBrB,EAAKkB,CAAS,KAChCjB,EAAIiB,CAAS,GAEfkB,EAAcC,CAAW;AAAA,IAC3B;AAGA,MAAApC,EAAIiB,CAAS;AAEf,IAAAG,IAAcrB,EAAKkB,CAAS;AAAA,EAC9B;AAGA,MAAIG,MAAgB;AACX,WAAA;AACF;AACC,UAAAqB,IAAa1C,EAAKmB,CAAU;AAClC,WAAIuB,MAAe,QACEV,EAAAO,GAAeG,EAAW,YAAYL,CAAW,GAE/D;AAAA,EACT;AACF;AAEA,SAASe,KAAoB;AAG3B,SAAI,EAFgBjB,EAAmB,IAAAN,IAErBC;AAOpB;AAEgB,SAAA0B,GACd/D,GACAwC,GACAwB,GACA;AAEA,QAAMpB,IAAcF;AAChBN,MAAAA;AAEJ,MAAI6B,EAASD,CAAO,KAAKA,MAAY,MAAM;AACzC,QAAIE,IAAQF,KAAA,gBAAAA,EAAS;AACrB,IAAI,OAAOE,KAAU,YAAYA,IAAQ,IACvC9B,IAAYQ,IAAcsB,IAE1B9B,IAAYQ;AAAA,EACd;AAEAR,IAAAA,IAAYQ;AAGR,QAAA3C,IAAUF,EAA0BC,CAAa,GACjDmE,IAAiB/B,IAAYnC,GAE7BmE,IAAU;AAAA,IACd,IAAIzC;AAAA,IACJ,UAAAa;AAAA,IACA,eAAAxC;AAAA,IACA,WAAAoC;AAAAA,IACA,gBAAA+B;AAAA,IACA,WAAW;AAAA,EAAA;AAGb,EAAI/B,IAAYQ,KAEdwB,EAAQ,YAAYhC,GACpBlC,EAAKwB,GAAY0C,CAAO,GACpB7D,EAAKkB,CAAS,MAAM,QAAQ2C,MAAY7D,EAAKmB,CAAU,MAErDI,IACgBQ,MAEOR,IAAA,IAERS,EAAAO,GAAeV,IAAYQ,CAAW,OAG3DwB,EAAQ,YAAYD,GACpBjE,EAAKuB,GAAW2C,CAAO,GAEnB,CAACrC,KAA2B,CAACC,MACLD,IAAA,IAC1BgB,EAAoBC,CAAS;AAGnC;AAGO,SAASqB,GAAeC,GAAY;AAKzC,EAAAA,EAAK,WAAW;AAClB;AAGO,SAASC,KAAyC;AAChD,SAAA1C;AACT;AAEO,SAAS2C,KAAe;AAY/B;;;;;;;;"}