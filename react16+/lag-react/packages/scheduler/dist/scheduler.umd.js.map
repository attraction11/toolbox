{"version":3,"file":"scheduler.umd.js","sources":["../src/SchedulerPriorities.ts","../src/SchedulerMinHeap.ts","../src/Scheduler.ts"],"sourcesContent":["export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5;\n\n// 任务优先级\n// 优先级越高，值越小\nexport const NoPriority = 0;\nexport const ImmediatePriority = 1;\nexport const UserBlockingPriority = 2;\nexport const NormalPriority = 3;\nexport const LowPriority = 4;\nexport const IdlePriority = 5;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nconst maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nexport const IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nexport const USER_BLOCKING_PRIORITY_TIMEOUT = 250;\nexport const NORMAL_PRIORITY_TIMEOUT = 5000;\nexport const LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nexport const IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\n\nexport function getTimeoutByPriorityLevel(priorityLevel: PriorityLevel) {\n  let timeout: number;\n\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n      break;\n    case UserBlockingPriority:\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n      break;\n    case IdlePriority:\n      timeout = IDLE_PRIORITY_TIMEOUT;\n      break;\n    case LowPriority:\n      timeout = LOW_PRIORITY_TIMEOUT;\n      break;\n    case NormalPriority:\n    default:\n      timeout = NORMAL_PRIORITY_TIMEOUT;\n      break;\n  }\n\n  return timeout;\n}\n","export type Heap = Array<Node>;\n\nexport type Node = {\n  id: number;\n  sortIndex: number;\n};\n\nexport function push(heap: Heap, node: Node): void {\n  const index = heap.length;\n  heap.push(node);\n  siftUp(heap, node, index);\n}\n\nexport function peek(heap: Heap): Node | null {\n  return heap.length === 0 ? null : heap[0];\n}\n\nexport function pop(heap: Heap): Node | null {\n  if (heap.length === 0) {\n    return null;\n  }\n  const first = heap[0];\n  const last = heap.pop();\n  if (last !== first) {\n    heap[0] = last!;\n    siftDown(heap, last!, 0);\n  }\n  return first;\n}\n\nfunction siftUp(heap: Heap, node: Node, i: number) {\n  let index = i;\n  while (index > 0) {\n    const parentIndex = (index - 1) >>> 1;\n    const parent = heap[parentIndex];\n    if (compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node;\n      heap[index] = parent;\n      index = parentIndex;\n    } else {\n      // The parent is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction siftDown(heap: Heap, node: Node, i: number) {\n  let index = i;\n  const length = heap.length;\n  const halfLength = length >>> 1;\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1;\n    const left = heap[leftIndex];\n    const rightIndex = leftIndex + 1;\n    const right = heap[rightIndex];\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compare(left, node) < 0) {\n      if (rightIndex < length && compare(right, left) < 0) {\n        heap[index] = right;\n        heap[rightIndex] = node;\n        index = rightIndex;\n      } else {\n        heap[index] = left;\n        heap[leftIndex] = node;\n        index = leftIndex;\n      }\n    } else if (rightIndex < length && compare(right, node) < 0) {\n      heap[index] = right;\n      heap[rightIndex] = node;\n      index = rightIndex;\n    } else {\n      // Neither child is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction compare(a: Node, b: Node) {\n  // Compare sort index first, then task id.\n  const diff = a.sortIndex - b.sortIndex;\n  return diff !== 0 ? diff : a.id - b.id;\n}\n","import {push, pop, peek} from \"./SchedulerMinHeap\";\nimport {getCurrentTime, isFn, isObject} from \"shared/utils\";\nimport {\n  getTimeoutByPriorityLevel,\n  NormalPriority,\n  PriorityLevel,\n} from \"./SchedulerPriorities\";\n\ntype Callback = any; // (args: any) => void | any;\n\nexport interface Task {\n  id: number;\n  callback: Callback;\n  priorityLevel: PriorityLevel;\n  startTime: number;\n  expirationTime: number;\n  sortIndex: number;\n}\n\ntype HostCallback = (hasTimeRemaining: boolean, currentTime: number) => boolean;\n\n// 任务存储，最小堆\nconst taskQueue: Array<Task> = [];\nconst timerQueue: Array<Task> = [];\n\nlet taskIdCounter: number = 1;\n\nlet currentTask: Task | null = null;\nlet currentPriorityLevel: PriorityLevel = NormalPriority;\n\n// 在计时\nlet isHostTimeoutScheduled: boolean = false;\n\n// 在调度任务\nlet isHostCallbackScheduled = false;\n// This is set while performing work, to prevent re-entrance.\nlet isPerformingWork = false;\n\nlet schedulePerformWorkUntilDeadline: Function;\n\nlet isMessageLoopRunning = false;\nlet scheduledHostCallback: HostCallback | null = null;\nlet taskTimeoutID: number = -1;\n\nlet startTime = -1;\n\nlet needsPaint = false;\n\n// Scheduler periodically yields in case there is other work on the main\n// thread, like user events. By default, it yields multiple times per frame.\n// It does not attempt to align with frame boundaries, since most tasks don't\n// need to be frame aligned; for those that do, use requestAnimationFrame.\nlet frameInterval = 5; //frameYieldMs;\n\nfunction cancelHostTimeout() {\n  clearTimeout(taskIdCounter);\n  taskIdCounter = -1;\n}\n\nfunction requestHostTimeout(callback: Callback, ms: number) {\n  taskIdCounter = setTimeout(() => {\n    callback(getCurrentTime());\n  }, ms);\n}\n\n// 检查timerQueue中的任务，是否有任务到期了呢，到期了就把当前有效任务移动到taskQueue\nfunction advanceTimers(currentTime: number) {\n  let timer: Task = peek(timerQueue) as Task;\n  while (timer !== null) {\n    if (timer.callback === null) {\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n    } else {\n      return;\n    }\n    timer = peek(timerQueue) as Task;\n  }\n}\n\n// 倒计时到点了\nfunction handleTimeout(currentTime: number) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else {\n      const firstTimer: Task = peek(timerQueue) as Task;\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\n\n// todo\nfunction requestHostCallback(callback: Callback) {\n  scheduledHostCallback = callback;\n\n  if (!isMessageLoopRunning) {\n    isMessageLoopRunning = true;\n    schedulePerformWorkUntilDeadline();\n  }\n}\n\nconst performWorkUntilDeadline = () => {\n  if (scheduledHostCallback !== null) {\n    const currentTime = getCurrentTime();\n\n    // Keep track of the start time so we can measure how long the main thread\n    // has been blocked.\n    startTime = currentTime;\n\n    const hasTimeRemaining = true;\n    let hasMoreWork = true;\n    try {\n      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n    } finally {\n      if (hasMoreWork) {\n        schedulePerformWorkUntilDeadline();\n      } else {\n        isMessageLoopRunning = false;\n        scheduledHostCallback = null;\n      }\n    }\n  } else {\n    isMessageLoopRunning = false;\n  }\n};\n\nconst channel = new MessageChannel();\n\nconst port = channel.port2;\n\nchannel.port1.onmessage = performWorkUntilDeadline;\n\nschedulePerformWorkUntilDeadline = () => {\n  port.postMessage(null);\n};\n\nfunction flushWork(hasTimeRemaining: boolean, initialTime: number) {\n  isHostCallbackScheduled = false;\n\n  if (isHostTimeoutScheduled) {\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  isPerformingWork = true;\n\n  let previousPriorityLevel = currentPriorityLevel;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n  }\n}\n\n// 在当前时间切片内循环执行任务\nfunction workLoop(hasTimeRemaining: boolean, initialTime: number) {\n  let currentTime = initialTime;\n\n  advanceTimers(currentTime);\n  currentTask = peek(taskQueue) as Task;\n\n  while (currentTask !== null) {\n    const should = shouldYieldToHost();\n    if (\n      currentTask.expirationTime > currentTime &&\n      (!hasTimeRemaining || should)\n    ) {\n      // 当前任务还没有过期，并且没有剩余时间了\n      break;\n    }\n\n    const callback = currentTask.callback;\n    currentPriorityLevel = currentTask.priorityLevel;\n    if (isFn(callback)) {\n      currentTask.callback = null;\n\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n\n      const continuationCallback = callback(didUserCallbackTimeout);\n\n      currentTime = getCurrentTime();\n      if (isFn(continuationCallback)) {\n        // 任务没有执行完\n        currentTask.callback = continuationCallback;\n        advanceTimers(currentTime);\n        return true;\n      } else {\n        if (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n        advanceTimers(currentTime);\n      }\n    } else {\n      // currentTask不是有效任务\n      pop(taskQueue);\n    }\n    currentTask = peek(taskQueue) as Task;\n  }\n\n  // 判断还有没有其他的任务\n  if (currentTask !== null) {\n    return true;\n  } else {\n    const firstTimer = peek(timerQueue) as Task;\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n    return false;\n  }\n}\n\nfunction shouldYieldToHost() {\n  const timeElapsed = getCurrentTime() - startTime;\n\n  if (timeElapsed < frameInterval) {\n    // The main thread has only been blocked for a really short amount of time;\n    // smaller than a single frame. Don't yield yet.\n    return false;\n  }\n\n  return true;\n}\n\nexport function scheduleCallback(\n  priorityLevel: PriorityLevel,\n  callback: Callback,\n  options?: {delay: number}\n) {\n  //任务进入调度器的时间\n  const currentTime = getCurrentTime();\n  let startTime: number;\n\n  if (isObject(options) && options !== null) {\n    let delay = options?.delay;\n    if (typeof delay === \"number\" && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n  } else {\n    startTime = currentTime;\n  }\n\n  const timeout = getTimeoutByPriorityLevel(priorityLevel);\n  const expirationTime = startTime + timeout;\n\n  const newTask = {\n    id: taskIdCounter++,\n    callback,\n    priorityLevel,\n    startTime, //任务开始调度的理论时间\n    expirationTime, //过期时间\n    sortIndex: -1,\n  };\n\n  if (startTime > currentTime) {\n    // 有延迟的任务\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n      //\n      if (isHostTimeoutScheduled) {\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      }\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    newTask.sortIndex = expirationTime;\n    push(taskQueue, newTask);\n\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n}\n\n// 取消任务\nexport function cancelCallback(task: Task) {\n  // Null out the callback to indicate the task has been canceled. (Can't\n  // remove from the queue because you can't remove arbitrary nodes from an\n  // array based heap, only the first one.)\n  // 取消任务，不能直接删除，因为最小堆中只能删除堆顶元素\n  task.callback = null;\n}\n\n// 获取当前任务优先级\nexport function getCurrentPriorityLevel(): PriorityLevel {\n  return currentPriorityLevel;\n}\n\nexport function requestPaint() {\n  // if (\n  //   enableIsInputPending &&\n  //   navigator !== undefined &&\n  //   // $FlowFixMe[prop-missing]\n  //   navigator.scheduling !== undefined &&\n  //   // $FlowFixMe[incompatible-type]\n  //   navigator.scheduling.isInputPending !== undefined\n  // ) {\n  //   needsPaint = true;\n  // }\n  // Since we yield every frame regardless, `requestPaint` has no effect.\n}\n\n// heap中谁的任务优先级最高先去执行谁，这里说的“任务优先级”不是priorityLevel\n"],"names":["getTimeoutByPriorityLevel","priorityLevel","timeout","push","heap","node","index","siftUp","peek","pop","first","last","siftDown","parentIndex","parent","compare","length","halfLength","leftIndex","left","rightIndex","right","a","b","diff","taskQueue","timerQueue","taskIdCounter","currentTask","currentPriorityLevel","isHostTimeoutScheduled","isHostCallbackScheduled","isPerformingWork","schedulePerformWorkUntilDeadline","isMessageLoopRunning","scheduledHostCallback","startTime","frameInterval","cancelHostTimeout","requestHostTimeout","callback","ms","getCurrentTime","advanceTimers","currentTime","timer","handleTimeout","requestHostCallback","flushWork","firstTimer","performWorkUntilDeadline","hasTimeRemaining","hasMoreWork","channel","port","initialTime","previousPriorityLevel","workLoop","should","shouldYieldToHost","isFn","didUserCallbackTimeout","continuationCallback","scheduleCallback","options","isObject","delay","expirationTime","newTask","cancelCallback","task","getCurrentPriorityLevel","requestPaint"],"mappings":"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"}